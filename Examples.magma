// Examples.magma
// Version 0.93
// 10 February 2026

// Code related to the paper:

// [Howe2026]
// Everett W. Howe:
// Curves of genus two with maps of every degree to a fixed elliptic curve,
// https://doi.org/10.48550/arXiv.2601.19050

/*
The paper referenced gives a list of pairs (tau, sigma) such that there is a 
genus-2 curve C over the complex numbers with period matrix
     [ 1 0 tau/2     1/2]
     [ 0 1   1/2 sigma/2]
and an elliptic curve with period matrix
     [  1]
     [tau]
such that there are maps of degree n from C to E for every n > 1. For each pair
(C,E), the paper also gives a quaternary quadratic form q(w,x,y,z) on Z^4 that
is isomorpic to the degree function on the group Hom_P(C,E) of morphisms from C
to E that take a fixed base point P on C to the origin on E.

The paper [Howe2026] also gives explicit equations for the curves C, with 
coefficients in number fields of degree at most 4.

The proGrams in this file gives further algebraic information for some of the
pairs (C,E): namely, equations for E and for four explicit morphisms
phi1, phi2, phi3, phi4 from C to E that take a fixed base point to the origin,
and such that 

  degree(n1*phi1 + n2*phi2 + n3*phi + n4*phi4) = q(n1,n2,n3,n4).

In other words, the examples are removed completely from the world of complex
analysis and into the world of algebra.

At the moment, only three examples are included. The examples are identified by
the discriminant of the endomorphism ring of E and the discriminant of the
endomorphism ring of an associated elliptic curve F. See [Howe2026] for
details. The three examples are for
  DeltaE = -4 , DeltaF = -100
  DeltaE = -10, DeltaF = -20
  DeltaE = -36, DeltaF = -36

The procedure VerifyManyMaps() will print out a sequence of triples
  DeltaE, DeltaF, G
where the first two numbers are the discriminants that identify a set of
Galois conjugate examples from [Howe2026], and G is the Gram matrix of the
degree map on a specific Z-basis for Hom_P(C,E).
*/



/* Change log:

Version 0.9 , 2026-01-26: 
First public version.

Version 0.91, 2026-01-28: 
Added second example, DeltaE = DeltaF = -20.

Version 0.92, 2026-01-21: 
Added third example, DeltaE = DeltaF = -36.
Edited first example to use different model of C.

Version 0.93, 2026-02-10: 
Reverted to the original form of the first example.
Added arXiv link.

*/


function pointdegree(P)
  // P is a point on the base extension of an elliptic curve
  // E/K to the function field of a hyperelliptic curve C/K.
  // Return the degree of the map from C to E over K associted to P.
  
  return Degree(P[1])/2;
end function;


function quadformmatrix(P1,P2,P3,P4);
  // Return the matrix of the bilnear form associated to the
  // degree funcion on the Z-module generated by P1, P2, P3, P4,
  // which are points on the base extension of an elliptic curve
  // E/K to the function field of a hyperelliptic curve C/K.

  d1 := pointdegree(P1);
  d2 := pointdegree(P2);
  d3 := pointdegree(P3);
  d4 := pointdegree(P4);
  e12 := pointdegree(P1 + P2);
  e13 := pointdegree(P1 + P3);
  e14 := pointdegree(P1 + P4);
  e23 := pointdegree(P2 + P3);
  e24 := pointdegree(P2 + P4);
  e34 := pointdegree(P3 + P4);
  return Matrix(4,
      [          d1, (e12-d1-d2)/2, (e13-d1-d3)/2, (e14-d1-d4)/2, 
      (e12-d2-d1)/2,            d2, (e23-d2-d3)/2, (e24-d2-d4)/2, 
      (e13-d3-d1)/2, (e23-d3-d2)/2,            d3, (e34-d3-d4)/2, 
      (e14-d4-d1)/2, (e24-d4-d2)/2, (e34-d4-d3)/2, d4            ]);
end function;


procedure VerifyManyMaps()

  S<w>:=PolynomialRing(Rationals());
  
  // The Gram matrices of the four quadratic forms in [Howe2026].
  Gram1 := Matrix(4,[Rationals()|2, 0, 0, 0, 0, 3, 1, 0, 0, 1, 3, 0, 0, 0, 0, 4]);
  Gram2 := Matrix(4,[Rationals()|2, 0, 0, 1, 0, 2, 1, 0, 0, 1, 3, 0, 1, 0, 0, 3]);
  Gram3 := Matrix(4,[Rationals()|2, 1, 1, 0, 1, 3, 0, 1, 1, 0, 3, 1, 0, 1, 1, 4]);
  Gram4 := Matrix(4,[Rationals()|2,-1, 0, 1,-1, 3, 1, 0, 0, 1, 4, 2, 1, 0, 2, 6]);

  

  // ===========================================================================
  // First example:
  DeltaE := -4;
  DeltaF := -100;
  
  // Define the number field over which the curves and maps are rational:
  
  K<alpha>:=NumberField(w^4 - 8*w^2 + 36);
  i := 1/12*(alpha^3 - 2*alpha);
  s := 1/12*(alpha^3 - 14*alpha);
  r := (s+1)/2;
  assert i^2 + 1 eq 0;
  assert s^2 - 5 eq 0;
  assert r^2 - r - 1 eq 0;
  
  Z<z>:=PolynomialRing(K);
  f := (z^6 - 3*z^4 + (2 + r^24)*z^2 - r^24);
  
  // Note the factored form:
  assert f eq (z^2 - 1)*(z^4 - 2*z^2 + r^24);

  C := HyperellipticCurve(f);
  L<x,y>:=FunctionField(C);

  ec4 := z^3 + 9*s*z;
  E := EllipticCurve(ec4);

  // Verify that this has CM by -4:
  assert Evaluate(HilbertClassPolynomial(-4),jInvariant(E)) eq 0;
  
  EL := BaseExtend(E,L);
  
  // Following notation in Section 5 of [Howe2026].

  P2 := 36*s*r^6 / (x^2 - 1);
  Q2 := -18*s*r^3/ (x^2 - 1)^2;

  P3 := -3*r * (x + 1) * (x^2 - 6*r^3 * x + r^12)
           / (x - 1)   / (s*x + r^6)^2;
  Q3 := -9*r * ((1-2*s)*x^2 - 2*x - r^6)
           / (x - 1)^2 / (s*x + r^6)^3;
           
  phi1 := EL![ P2,  y*Q2];
  phi2 := EL![-P2,i*y*Q2];
  phi3 := EL![ P3,i*y*Q3];
  phi4 := EL![-P3,  y*Q3];
  
  Gram := quadformmatrix(phi1, phi2, phi3, phi4);

  print DeltaE, DeltaF, Gram;

  assert Gram eq Gram2;
  print "This is the correct Gram matrix.\n";


  // ===========================================================================
  // Second example:
  DeltaE := -20;
  DeltaF := -20;
  
  // Define the number field over which the curves and maps are rational:
  
  K<r>:=NumberField(w^4 - 8*w^2 + 36);
  s := 1/12*(r^3 - 14*r);
  i := 1/12*(r^3 - 2*r);
  assert i^2 + 1 eq 0;
  assert s^2 - 5 eq 0;
  
  Z<z>:=PolynomialRing(K);
  f := (s+2)*(z^5 + s*z^3 + z);

  C := HyperellipticCurve(f);
  L<x,y>:=FunctionField(C);

  
  ec20 := z^3 + (4*s - 8)*z^2 + (s - 2)*z;
  E := EllipticCurve(ec20);

  // Verify that this has CM by -20:
  assert Evaluate(HilbertClassPolynomial(-20),jInvariant(E)) eq 0;
  
  EL := BaseExtend(E,L);
  
  P2a := (s - 2) * (x-1)^2/x;
  Q2a := (4*s - 9)  * (x-1)/x^2 * y;
  phi1 := EL![P2a,Q2a];

  P2b := (-s + 2) * (x+1)^2/x;
  Q2b := i * (-4*s + 9) * (x+1)/x^2 * y;
  phi2 := EL![P2b,Q2b];


  P3a := (-5*s + 11)/2  * x * (x + (s+1)/2)^2                         / (x^2 + (s-1)/2);
  Q3a := i * (17*s - 38)    * (x + (s+1)/2)   * (x^2 - 2*x + (s+3)/2) / (x^2 + (s-1)/2)^2 * y;
  phi3 := EL![P3a,Q3a];


  P3b := (s-1)/2 * x * (x^2 + (s+1)/2)        / (x + (-s+1)/2)^2;
  Q3b := (s-2) * (x^2 + (-s+3)*x + (-s+3)/2)  / (x + (-s+1)/2)^3 * y;
  phi4 := EL![P3b,Q3b];

  
  Gram := quadformmatrix(phi1, phi2, phi3, phi4);

  print DeltaE, DeltaF, Gram;

  assert Gram eq Gram2;
  print "This is the correct Gram matrix.\n";
  
  
  // ===========================================================================
  // Third example:
  DeltaE := -36;
  DeltaF := -36;

 // Define the number field over which the curves and maps are rational:

  K<r>:=NumberField(w^4 - w^2 + 1);
  i := r^3;
  s := 2*r^4+1;  
  assert i^2 + 1 eq 0;
  assert s^2 + 3 eq 0;
  
  Z<z>:=PolynomialRing(K);
  f := z^5 + (12-8*s)*z^4 + (-6 - 73*s)*z^3 + (-252-168*s)*z^2 + (-423-72*s)*z;
  C := HyperellipticCurve(f);
  L<x,y>:=FunctionField(C);

  ec36overbase := z^3 + 8*i*s*z^2 + (14*i*s + 24)*z;
  ec36 := z^3 + 4*(s + i*s)*z^2 + (7*s-12*i)*z;
  Ebase := EllipticCurve(ec36overbase);
  E := EllipticCurve(ec36);

  // Verify that this has CM by -20:
  assert Evaluate(HilbertClassPolynomial(-36),jInvariant(E)) eq 0;
  
  // Verify that E is twist of Ebase by 1 + i:
  assert IsIsomorphic(E, QuadraticTwist(Ebase, 1+i));
  
  EL := BaseExtend(E,L);
  
  P2 := (-s-2*i)*(x - (2*i*s+3*i))^2/x;
  Q2 := (1+i)*(3*i*s - 5)/2 * (x - (2*i*s+3*i))/x^2;
  phi1 := EL![P2, y*Q2];

  P3 := 2 * (-2*s*i+29*s-90*i-47) * x * (x^2 + (6 - 2*s)*x + (15 - 11*s)/2)
         / (26*x - (-5*i*s + 92*s + 87*i - 72))^2;
  Q3 := (-i*s - 5*s + 7*i + 9)^3 * (x^2 + (i*s - 10*s -9*i + 6)*x + (-37*s - 3)/2)
        / (26*x - (-5*i*s + 92*s + 87*i - 72))^3;
  phi2 := EL![P3, y*Q3];

  P4 := (i*s + 2)/2 * (x^2 + (6 - 6*s)* x + (-27 - 39*s)/2) 
                    * (x^2 + (6 - 2*s)* x + (15 - 11*s)/2)
        / x / (x + (2*i*s + 3*i))^2;
  Q4 := (3*i*s + 5)/4 * (x^4 + (8*i*s + 12*i) * x^3 + (25*s + 168*i + 18)*x^2
                                + (-120*i*s + 324*i)*x + (-72*s-423))
        / x^2 / (x + (2*i*s + 3*i))^3;
  phi3 := EL![P4, y*Q4];
  
  P6 := ( 2 -3*i -2*s -i*s)/4
        * (x^2 + (6 - 2*s)*x + (15-11*s)/2)
        * (x^2 + (6 + 6*i - 6*s)*x + (9 - 15*s)/2)^2
        / x / (x + (6 - 3*i - 2*s - i*s)/2)^2 / (x^2 + (6 - 6*s)*x + (-27 - 39*s)/2);
  Q6 := (5*i + 3*s)/4 
        * (x^2 + (6 + 6*i - 6*s)*x + (9 - 15*s)/2)
        * ( x^6 + (12 -6*i-4*s-2*i*s)*x^5 + (51-144*i-91*s)/2*x^4
            + (-144-216*i-120*s+84*i*s)*x^3  + (-621 -216*i + 297*s + 360*i*s)/2 * x^2
            + (1188 + 540*s) * x + (4455 - 621*s)/2)        
        / x^2
        / (x + (6 - 3*i - 2*s - i*s)/2)^3
        / (x^2 + (6 - 6*s)*x + (-27 - 39*s)/2)^2;
  phi4 := EL[P6, y*Q6];
  
  Gram := quadformmatrix(phi1, phi2, phi3, phi4);

  print DeltaE, DeltaF, Gram;

  assert Gram eq Gram4;
  print "This is the correct Gram matrix.\n";
  

end procedure;

           

